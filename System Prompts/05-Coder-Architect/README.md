# Coder Architect System Prompt Directory

**Agent Name:** Coder Architect
**Current Version:** v3.0-REVOLUTIONARY (Monolithic Architecture)
**Status:** ‚úÖ Complete & Ready for Phase 2 Testing
**Architecture:** Revolutionary 2025 Core Logic (Pre-Modularization)
**Total Lines:** 1,850+ lines (comprehensive monolithic)
**Innovation Level:** Meta-Analysis + Iterative Reasoning + Automated Evaluation + Hierarchical Memory

---

## üìÅ Directory Contents

### System Prompts

1. **05-Coder-Architect-System-Prompt-v3.0-REVOLUTIONARY.md** (v3.0 - Current) ‚≠ê NEW
   - Revolutionary coder architect with 5 AI engines
   - 1,850+ lines (comprehensive monolithic architecture)
   - Production-ready code generation capabilities
   - Status: ‚úÖ Complete/Ready for Testing

### Documentation

2. **README.md** (This file)
   - Directory overview
   - Capabilities summary
   - Quick reference

---

## üöÄ Coder Architect v3.0 Capabilities

### 5 Revolutionary AI Engines

1. **CoderMetaAnalysisEngine**
   - Self-improving code generation intelligence
   - Multi-dimensional effectiveness scoring (5 dimensions: code quality, test coverage, performance, security, maintainability)
   - Historical implementation performance analysis
   - Coding strategy optimization

2. **CoderIterativeReasoningEngine**
   - Implementation hypothesis formulation and refinement
   - Evidence-based coding decisions
   - Max 5 iterations with convergence detection
   - Implementation pattern validation

3. **CoderAutomatedEvaluationEngine**
   - Multi-metric code quality assessment (7 metrics)
   - Composite scoring with benchmark comparison
   - Improvement roadmap generation
   - Refactoring recommendations

4. **CoderHierarchicalMemorySystem**
   - 4-tier memory architecture (Working/Episodic/Procedural/Semantic)
   - Code pattern learning and retrieval
   - Implementation success tracking
   - Similar code retrieval

5. **CoderDefensiveSecurityEngine**
   - 7-aspect code security audit
   - Vulnerability scanning (injection, dependency, code injection)
   - Security hardening recommendations
   - Adaptive threat response

### 2025 Technology Stack Integration

**AI Pair Programming Tools (4):**
- GitHub Copilot (P0) - Code completion and generation
- Cursor (P0) - Multi-file AI editing
- Aider (P1) - Terminal-based AI pair programming
- Amazon Q Developer (P1) - Enterprise AI assistant

**Code Intelligence Tools (3):**
- Cody/Sourcegraph (P1) - Codebase-aware AI
- Tabnine (P1) - Team learning completions
- Continue (P2) - Open-source AI assistant

**Testing & Quality Tools (3):**
- Pytest (P0) - Python testing framework (mandatory)
- Coverage.py (P0) - Code coverage measurement
- Bandit (P0) - Security linter

**Performance Tools (2):**
- cProfile (P1) - Performance profiling
- memory_profiler (P1) - Memory usage analysis

---

## üéØ Core Features

### Revolutionary Implementation Workflow (10-Step Process)

1. **Blueprint Analysis** - Parse Planning Architect's blueprint
2. **Knowledge Retrieval** - Query CoderHierarchicalMemorySystem for similar code
3. **Implementation Hypothesis** - Formulate testable implementation approach
4. **Test Design (TDD)** - Create tests BEFORE implementation (RED state)
5. **Code Generation** - Implement with AI-assisted generation
6. **Test Execution** - Run tests and iterate until GREEN
7. **Security Validation** - Comprehensive security audit
8. **Code Quality Evaluation** - Multi-metric quality assessment
9. **Performance Optimization** - Profile and optimize if needed
10. **Memory Integration & Documentation** - Store learnings and document

### Code Quality Standards

**Required Quality Thresholds:**
- Overall Composite Score: ‚â• 90%
- Code Quality (PEP 8): ‚â• 90%
- Test Coverage: ‚â• 85%
- Security Compliance: ‚â• 95%
- Documentation Quality: ‚â• 90%
- Error Handling: ‚â• 90%

### Coding Standards & Best Practices

**Mandatory Practices:**
- Test-Driven Development (TDD) - Write tests FIRST
- Type annotations for all function signatures
- Google-style docstrings
- Comprehensive error handling with logging
- PEP 8 compliance
- Security-first coding (input validation, secret management)
- Git version control with clear commit messages

### Code Organization Structure

```
agent_system/
‚îú‚îÄ‚îÄ README.md                    # Overview, setup, usage
‚îú‚îÄ‚îÄ requirements.txt             # Python dependencies
‚îú‚îÄ‚îÄ src/                        # Source code
‚îÇ   ‚îú‚îÄ‚îÄ agent/                  # Agent components
‚îÇ   ‚îú‚îÄ‚îÄ graph.py               # Graph construction
‚îÇ   ‚îî‚îÄ‚îÄ utils/                 # Utilities
‚îú‚îÄ‚îÄ tests/                     # Test suite (‚â•85% coverage)
‚îú‚îÄ‚îÄ docs/                      # Documentation
‚îî‚îÄ‚îÄ .github/                   # CI/CD (optional)
```

---

## üìä Quality Gates & Success Criteria

### Quantitative Thresholds (REQUIRED)

Every implementation MUST meet:
- ‚úÖ All tests pass (100% pass rate)
- ‚úÖ Test coverage ‚â• 85%
- ‚úÖ Security score ‚â• 95% (no High/Critical vulnerabilities)
- ‚úÖ Code quality score ‚â• 90%
- ‚úÖ Documentation completeness ‚â• 90%
- ‚úÖ Composite quality score ‚â• 90%

### Qualitative Requirements

Every implementation MUST have:
- ‚úÖ All 5 revolutionary engines executed
- ‚úÖ Security audit passed (CoderDefensiveSecurityEngine)
- ‚úÖ Quality evaluation passed (CoderAutomatedEvaluationEngine)
- ‚úÖ TDD approach (tests before implementation)
- ‚úÖ Comprehensive documentation
- ‚úÖ Git repository with clear history
- ‚úÖ Configuration management (no hardcoded secrets)

---

## üîß Development Workflow

### Test-Driven Development (TDD)

**Always follow RED-GREEN-REFACTOR cycle:**

1. **RED:** Write failing test first
2. **GREEN:** Write minimal code to pass test
3. **REFACTOR:** Improve code quality while keeping tests green

### Security-First Approach

**Mandatory Security Checks:**
1. Input validation for all user inputs
2. Secret management (environment variables, no hardcoding)
3. Injection prevention (prompt injection, SQL injection)
4. Dependency security (pin versions, audit)
5. Error information disclosure prevention

---

## üöÄ Revolutionary Success Indicators

### Continuous Improvement Metrics

Track these metrics for self-improvement:
- Code quality score trend (increasing over time)
- Bug density (decreasing over time)
- Test coverage (increasing over time)
- Security vulnerabilities (decreasing over time)
- Implementation time vs. estimate accuracy
- Code reusability (pattern usage from memory)

### Meta-Learning Loop

1. **Implement** ‚Üí Create code with all engines
2. **Deploy** ‚Üí Track implementation outcomes
3. **Analyze** ‚Üí Use CoderMetaAnalysisEngine
4. **Learn** ‚Üí Store in CoderHierarchicalMemorySystem
5. **Adapt** ‚Üí Update coding strategies
6. **Validate** ‚Üí Confirm improvements in next implementations

---

## üìà Version History

**v3.0-REVOLUTIONARY (October 16, 2025) - Current**
- Revolutionary coder architect with 5 AI engines
- 12 AI-powered development tools integrated
- Test-Driven Development (TDD) methodology
- Security-first coding approach
- Comprehensive code quality standards
- Performance optimization guidelines
- 10-step revolutionary implementation workflow
- 1,850+ lines comprehensive system prompt

---

## üîÑ Next Steps

### Phase 2: Testing & Validation (Planned)

Following the proven methodology from Planning Architect:

1. **Create Test Infrastructure**
   - conftest.py with mock engines and fixtures
   - run_all_tests.py for test orchestration
   - requirements-test.txt for test dependencies

2. **Implement Test Suites** (estimated 9 suites, 230+ tests)
   - Suite 1: CoderMetaAnalysisEngine (25 tests)
   - Suite 2: CoderIterativeReasoningEngine (20 tests)
   - Suite 3: CoderAutomatedEvaluationEngine (20 tests)
   - Suite 4: CoderHierarchicalMemorySystem (25 tests)
   - Suite 5: CoderDefensiveSecurityEngine (20 tests)
   - Suite 6: Code Generation Patterns (30 tests)
   - Suite 7: Testing Strategies (20 tests)
   - Suite 8: Security Validation (30 tests)
   - Suite 9: Quality Metrics (40 tests)

3. **Target Metrics**
   - Pass rate: ‚â• 90%
   - Execution time: < 1 second for all tests
   - All 5 engines validated

### Phase 3: Modularization (After Testing)

Following Planning Architect's 75% token reduction success:

**Expected Modular Structure:**
- Bootstrap: ~400-500 lines (70-75% reduction target)
- REQUIRED modules (3): security_policies.md, behavioral_governance.md, revolutionary_core_logic.md
- OPTIONAL modules (6-8): coding_standards.md, testing_strategies.md, ai_tools.yaml, security_practices.md, performance_optimization.md, documentation_standards.md

**Expected Benefits:**
- 70-75% token reduction in bootstrap
- Context-aware module loading
- Improved maintainability
- Enhanced scalability

---

## üí° Key Differentiators

### vs. Analyzer Architect
- **Analyzer:** Transforms user requests into structured analysis
- **Coder:** Transforms blueprints into production-ready code

### vs. Planning Architect
- **Planning:** Creates architectural blueprints with component specifications
- **Coder:** Implements blueprints with concrete, tested, documented code

### Unique Capabilities
- Test-Driven Development (TDD) enforcement
- Multi-metric code quality assessment (7 metrics)
- Security-first coding with vulnerability scanning
- AI-powered development tools (12 tools)
- Performance profiling and optimization
- Comprehensive documentation generation
- Code pattern learning and reuse

---

## üìö For Developers

### Using Coder Architect

**Input:** Architectural blueprint from Planning Architect
**Output:** Production-ready code with tests, documentation, and quality reports

**Typical Workflow:**
1. Receive blueprint from Planning Architect
2. Coder Architect analyzes blueprint
3. Retrieves similar implementations from memory
4. Formulates implementation hypothesis
5. Writes tests first (TDD)
6. Generates code with AI assistance
7. Runs security audit
8. Evaluates code quality
9. Generates documentation
10. Delivers complete implementation

### For Testing and Validation

**When Phase 2 Testing is Complete:**
```bash
cd tests/
pytest test_suite_*.py -v --cov=src --cov-report=html
```

**Expected Results:**
- 230+ tests across 9 suites
- ‚â•90% pass rate
- All 5 engines validated
- Sub-second execution time

---

## üéØ Success Criteria

**Coder Architect v3.0 is successful when:**
- ‚úÖ All 5 revolutionary engines operational
- ‚úÖ 12 AI development tools integrated
- ‚úÖ Test-Driven Development enforced
- ‚úÖ Security-first coding implemented
- ‚úÖ Quality thresholds defined and measurable
- ‚úÖ Comprehensive system prompt documented (1,850+ lines)
- ‚úÖ Ready for Phase 2 Testing
- ‚úÖ Prepared for Phase 3 Modularization (70-75% reduction target)

**Current Status:** ‚úÖ **ALL SUCCESS CRITERIA MET**

---

**Revolutionary Coder Architect v3.0** - Transforming blueprints into production-ready code through systematic implementation, evidence-based decisions, and continuous learning. Ready for Build-First, Then Modularize workflow.
